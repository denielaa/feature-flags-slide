import { CodeSurfer as Surfer } from "code-surfer";
import { Appear, Background } from "gatsby-theme-mdx-deck";
import customTheme from "../src/theme";
import * as L from "../src/layout";

export const theme = customTheme;

<L.Column sx={{ minHeight: '60%', ml: 5 }}>

# Feature Flags & Continuous Delivery

</L.Column>

---

<L.Column>

# Hi! 👋🏻 I'm **Deniel**

- A Mediocre Software Engineer
- 13 years of experience as a Software Engineer
- ~ 7 years experience working remotely
- Fullstack (BE heavy) -> Frontend

</L.Column>

---

import Release from '../assets/release.webp';

## Release a major new feature

<img src={Release} width="40%" />

---

import SystemError from '../assets/system-error.webp';

<img src={SystemError} width="80%" />

---

import UserError from '../assets/user-error.jpeg';

<img src={UserError} width="40%" />

---

<L.Column>

## Solutions

<ul>
  <li>Maintenance mode</li>
  <li>Rollback</li>
</ul>

### ...but a better option is _Feature Flags_

</L.Column>

---

<L.Column>

## Today we'll learn about...

- What are Feature Flags?
- Why are Feature Flags useful?
- Drawbacks of Feature Flags
- How to implement Feature Flags? _(Best Practices)_

### ...and how to _work remotely in Global Company_

</L.Column>

---

import LightSwitch from '../assets/switch.jpg';

## What are Feature Flags?

<img src={LightSwitch} width="10%" />

---

<Surfer>

```js title="Feature Flags"
if (featureFlags.isFeatureEnabled('NewPaymentOption')) {
  RenderNewPaymentOption()
} else {
  RenderOldPaymentOption()
}
```

</Surfer>

---

<Surfer>

```js title="Release a new payment option"
import { CreditCardPayment } from './CreditCardPayment';
import { BitcoinPayment } from './BitcoinPayment';
import { NewPaymentOption } from './NewPaymentOption';

const PaymentOptions = () => {
  return (
    <div>
      <h3>Select payment option:</h3>
      <ul>
        <li><CreditCardPayment /></li>
        <li><BitcoinPayment /></li>
        <li><NewPaymentOption /></li>
      </ul>
    </div>
  );
};
```

```js title="Release with Feature Flag"
import { CreditCardPayment } from './CreditCardPayment';
import { BitcoinPayment } from './BitcoinPayment';
import { NewPaymentOption } from './NewPaymentOption';
import { featureFlags } from './featureFlags';

const PaymentOptions = () => {
  return (
    <div>
      <h3>Select payment option:</h3>
      <ul>
        <li><CreditCardPayment /></li>
        <li><BitcoinPayment /></li>
        {featureFlags.isFeatureEnabled('NewPaymentOption') &&
          <li><NewPaymentOption /></li>
        }
      </ul>
    </div>
  );
};
```

</Surfer>

---

## Type of Feature Flags



#### Boolean (On/Off)

---

<L.Row>

## Benefits of Feature Flags

### Why is this simple if statement so powerful?

</L.Row>

- A schema formalises data dependencies and relations
- GraphQL can be self-documenting and efficient
- GraphQL can be optimised well on the frontend and backend

### GraphQL's constraints are good for usability and automatic optimisations!

---

## More Questions?

<L.Column>

LinkedIn [denielaa](https://www.linkedin.com/in/denielaa/)

</L.Column>

---

<Background />
<L.Row>

## There's always more that can be done.

<Cereal />
</L.Row>

- Logging exchange.
- Support for Subscriptions.
- Rewriting the Exchange pipeline with streams.
- Normalised caching.
