import { CodeSurfer as Surfer } from "code-surfer";
import { Appear, Background } from "gatsby-theme-mdx-deck";
import Cereal from "../assets/cereal.svg";
import customTheme from "../src/theme";
import * as L from "../src/layout";
export const theme = customTheme;

import FormidableIntro from '../assets/formidable-intro.svg';

<L.Column sx={{ minHeight: '60%', ml: 5 }}>

# How to build a GraphQL Client from scratch.

<FormidableIntro />
</L.Column>

---

<L.Row>

## About these slides

### This is an `mdx-deck` slide deck.

</L.Row>

- Press `alt-g` for the *Grid Mode*.
- Press `alt-o` for the *Overview Mode*.
- Press `alt-f` for *Fullscreen*.

---

<L.Column>

## About this workshop

- This is a _code-along workshop_ with bite-sized steps
- The code is interleaved with lots of _in-depth explanations_
- Feel free to _ask questions anytime!_
- Pairing is encouraged

</L.Column>

---

import GraphQLLogo from '../assets/graphql-logo.svg';

<L.Row>
<GraphQLLogo />

### If you're here you're probably already sold on _GraphQL_...

</L.Row>

---

<L.Column>

## Today we'll learn about...

- GraphQL over HTTP
- GraphQL AST Documents
- Operation and Result Events
- Extensibility via Exchanges
- Document Caching

### ...to build a basic _GraphQL Client_ from scratch!

</L.Column>

---

<L.Column>

## Setup

```bash
git clone https://github.com/FormidableLabs/advanced-graphql-workshop.git
# or
npx degit FormidableLabs/advanced-graphql-workshop

npm install
# or
yarn install
```

Contact us with any questions on Twitter! [@_philpl](https://twitter.com/_philpl) and [@sofiapoh](https://twitter.com/sofiapoh)

</L.Column>

---

import FinishedApp from '../assets/finished-app.jpg';

<img src={FinishedApp} />

---

<Surfer>

```js title="A usual query in GraphQL"
import gql from 'graphql-tag';

const THREADS_QUERY = gql`
  query Threads($sortBy: SortBy!, $skip: Int, $limit: Int) {
    threads(sortBy: $sortBy, limit: $limit, skip: $skip) {
      id
      text
      title
      createdBy {
        id
        username
      }
      createdAt
      hasUserLiked
      likesNumber
      repliesNumber
    }
  }
`;
```

```js title="Our desired React hooks API"
import gql from 'graphql-tag';

const THREADS_QUERY = gql`
  query Threads($sortBy: SortBy!, $skip: Int, $limit: Int) {
    threads(sortBy: $sortBy, limit: $limit, skip: $skip) {
      id
      text
      title
      createdBy {
        id
        username
      }
      createdAt
      hasUserLiked
      likesNumber
      repliesNumber
    }
  }
`;

const { data, errors, fetching } = useQuery({
  query: THREADS_QUERY,
  variables: { sortBy, skip, limit }
});
```

</Surfer>

---

<L.Row>

## `useQuery`

### The hook will automatically execute and return the result and an execute function

</L.Row>

```js
const [result, executeQuery] = useQuery({
  query: gql`query { ... }`,
  variables: { /* vars */ }
});

const { data, error, fetching } = result;
```

---

<L.Row>

## `useMutation`

### The hook will return the last result and an execute function returning a Promise

</L.Row>

```js
const [result, executeMutation] = useMutation(
  gql`mutation { ... }`
);

const { data, error, fetching } = result;

const run = async () => {
  const result = await executeMutation({ /* vars */ });
  const { data, error } = result;
};
```

---

<L.Row>

## Extensible Client

### Our client will be extensible and manage the global state globally

</L.Row>

```js
const client = new Client('/graphql', {
  exchanges: [ /*... */ ],
  fetchOptions: { }
});
```

- Its' functionality will be split into "Exchanges" with separate concerns.
- It's a hub for all of our GraphQL requests.

---

import GraphQLRequests from '../assets/graphql-requests.svg';

## GraphQL HTTP Requests.

<GraphQLRequests />

---

import GraphQLDocParsing from '../assets/graphql-doc-parsing.svg';

<L.Row>

## GraphQL Documents.

### The three ways to typically define GraphQL queries.

</L.Row>

<GraphQLDocParsing />

---

<Surfer>

```js title="useRequest is used to normalize our hook input"
import { useMemo } from 'react';
import { parse } from 'graphql';

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, [query, variables]);
};
```

```diff 7:9 title="We normalize the input query to a DocumentNode"
```

```diff 1,5[10:16],12[6:23] title="We only recreate the request when the input changes"
```

```js title="For now, we'll keep dependencies empty until we add 'keys'"
/* eslint-disable react-hooks/exhaustive-deps */
import { useMemo } from 'react';
import { parse } from 'graphql';

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, []);
};
```

</Surfer>

---

<L.Row>

## GraphQL over REST.

### Why would we want to use GraphQL?

</L.Row>

- A schema formalises data dependencies and relations
- GraphQL can be self-documenting and efficient
- GraphQL can be optimised well on the frontend and backend

### GraphQL's constraints are good for usability and automatic optimisations!

---

<L.Row>

## GraphQL and React.

### Why would we want a GraphQL client library?

</L.Row>

- View-layer abstraction for GraphQL queries and mutations.
- Data transfer-layer and render agnostic event management.
- Centralised caching of results and types.
- Central place for optimisations and requirements.

---

<L.Row>

## The GraphQL Language

### GraphQL has a language for schemas and queries

</L.Row>

<L.Row noAlign>

```graphql
type Query {
  movies: [Movie]!
}

type Movie {
  id: ID!
  title: String!
  author: Author
}

type Author {
  id: ID!
  name: String!
}
```

```graphql
query {
  movies {
    id
    title
    author {
      id
      name
    }
  }
}
```

</L.Row>

---

<L.Row>

## Demystifying GraphQL Documents.

### Diving into the GraphQL AST structure to understand how GraphQL works.

</L.Row>

---

import GraphQLDocSimple from '../assets/graphql-doc-simple.svg';

<L.Row>

## GraphQL Documents.

### Every document may contain operations, and every operation has a selection set.

</L.Row>

<GraphQLDocSimple />

---

import GraphQLDocVars from '../assets/graphql-doc-vars.svg';

<L.Row>

## GraphQL Documents.

### Operations may define several variables with type annotations.

</L.Row>

<GraphQLDocVars />

---

import GraphQLFieldSimple from '../assets/graphql-field-simple.svg';

<L.Row>

## GraphQL Documents.

### Similarly to operations, fields may have arguments and selections.

</L.Row>

<GraphQLFieldSimple />

---

import GraphQLSelectionSetNode from '../assets/graphql-selectionset-node.svg';

<L.Row>

## GraphQL Documents.

### Selection sets may contain fields, fragment references, or inline fragments.

</L.Row>

<GraphQLSelectionSetNode />

---

import GraphQLSelections from '../assets/graphql-selections.svg';

<L.Column>

## GraphQL Documents.

<GraphQLSelections />

</L.Column>

---

<Background />

<L.Row>
<Cereal />

### We've now learned about the GraphQL AST, which will come in handy later...

</L.Row>

---

<Surfer>

```js title="Our first useQuery hook"
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);

  return {
    data: undefined,
    error: undefined,
    fetching: true
  };
};
```

```js
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);

  return {
    data: undefined,
    error: undefined,
    fetching: true
  };
};
```

```js title="We'll operate on local state which will hold our results"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  return result;
};
```

```js title="We'll create an effect where we'll execute our HTTP request"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));
  }, []);

  return result;
};
```

```js title="Adding a normal fetch request for GraphQL results"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    const options = {
      method: 'POST',
      body: JSON.stringify({
        query: print(request.query),
        variables: request.variables
      })
    };

    fetch('/graphql', options)
      .then(res => res.json())
      .then(({ data, errors }) => {
        setResult({
          data,
          errors,
          fetching: false
        });
      });
  }, [request]);

  return result;
};
```

```js title="Let's not forget the Content-Type header"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    const options = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(request.query),
        variables: request.variables
      })
    };

    fetch('/graphql', options)
      .then(res => res.json())
      .then(({ data, errors }) => {
        setResult({
          data,
          errors,
          fetching: false
        });
      });
  }, [request]);

  return result;
};
```

```js title="We'll handle status codes early"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    const options = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(request.query),
        variables: request.variables
      })
    };

    fetch('/graphql', options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json()
        }
      })
      .then(({ data, errors }) => {
        setResult({
          data,
          errors,
          fetching: false
        });
      });
  }, [request]);

  return result;
};
```

```js title="And normalise any unexpected errors"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    const options = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(request.query),
        variables: request.variables
      })
    };

    fetch('/graphql', options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json()
        }
      })
      .then(({ data, errors }) => {
        setResult({
          data,
          errors,
          fetching: false
        });
      })
      .catch(error => {
        setResult({
          data: undefined,
          errors: [error],
          fetching: false
        });
      });
  }, [request]);

  return result;
};
```

</Surfer>

---

<L.Column>

## Our first `useQuery` hook

- Basic effect & state hook
- No variables diffing
- No shared data or updates

</L.Column>

---

<L.Column>

## Shared Client code.

### Since we're building an infrastructure that has a _central client_, we'll need to define structures that abstract our _GraphQL inputs & outputs_.

</L.Column>

---

import Operations from '../assets/operations.svg';

<L.Row>

## Operations.

### The internal structure we'll use to abstract GraphQL requests.

</L.Row>

<Operations />

---

import OperationKeys from '../assets/operation-keys.svg';

<L.Column>

## Operation Keys.

<OperationKeys />

</L.Column>

---

<Surfer>

```js title="We'll extend useRequest to create operations"
/* eslint-disable react-hooks/exhaustive-deps */
import { useMemo } from 'react';
import { parse } from 'graphql';

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, []);
};
```

```js title="We'll fix up the hook dependencies in this step"
import { useMemo } from 'react';
import { parse } from 'graphql';

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, []);
};
```

```js title="We'll make a separate createRequest function"
import { useMemo } from 'react';
import { parse } from 'graphql';

export const createRequest = (operationName, query, variables) => {
  let str = typeof query !== 'string'
      ? print(query)
      : query;
  if (variables) {
    str += stringify(variables);
  }

  return {
    key: hash(str),
    operationName,
    query,
    variables
  };
};

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, []);
};
```

```js title="Let's add the missing dependencies that we'll need"
import { useMemo, useRef } from 'react';
import { parse } from 'graphql';
import hash from 'djb2a';
import stringify from 'fast-json-stable-stringify';

export const createRequest = (operationName, query, variables) => {
  let str = typeof query !== 'string'
      ? print(query)
      : query;
  if (variables) {
    str += stringify(variables);
  }

  return {
    key: hash(str),
    operationName,
    query,
    variables
  };
};

export const useRequest = (query, variables) => {
  return useMemo(() => {
    return {
      query: typeof query === 'string'
        ? parse(query)
        : query,
      variables
    };
  }, []);
};
```

```js title="Let's update useRequest now"
import { useMemo, useRef } from 'react';
import { parse } from 'graphql';
import hash from 'djb2a';
import stringify from 'fast-json-stable-stringify';

export const createRequest = (operationName, query, variables) => {
  let str = typeof query !== 'string'
      ? print(query)
      : query;
  if (variables) {
    str += stringify(variables);
  }

  return {
    key: hash(str),
    operationName,
    query,
    variables
  };
};

export const useRequest = (operationName, query, variables) => {
  return useMemo(() => {
    const request = createRequest(operationName, query, variables);
    return request;
  }, [operationName, query, variables]);
};
```

```js title="Let's update useRequest now"
import { useMemo, useRef } from 'react';
import { parse } from 'graphql';
import hash from 'djb2a';
import stringify from 'fast-json-stable-stringify';

export const createRequest = (operationName, query, variables) => {
  let str = typeof query !== 'string'
      ? print(query)
      : query;
  if (variables) {
    str += stringify(variables);
  }

  return {
    key: hash(str),
    operationName,
    query: typeof query === 'string'
      ? parse(query)
      : query,
    variables
  };
};

export const useRequest = (operationName, query, variables) => {
  return useMemo(() => {
    const request = createRequest(operationName, query, variables);
    return request;
  }, [operationName, query, variables]);
};
```

```js title="Let's make sure to only change the ref of the operation when it's needed"
import { useMemo, useRef } from 'react';
import { parse } from 'graphql';
import hash from 'djb2a';
import stringify from 'fast-json-stable-stringify';

export const createRequest = (operationName, query, variables) => {
  let str = typeof query !== 'string'
      ? print(query)
      : query;
  if (variables) {
    str += stringify(variables);
  }

  return {
    key: hash(str),
    operationName,
    query,
    variables
  };
};

export const useRequest = (operationName, query, variables) => {
  const prev = useRef();

  return useMemo(() => {
    const request = createRequest(operationName, query, variables);
    if (prev.current !== undefined && prev.current.key === request.key) {
      return prev.current;
    } else {
      return (prev.current = request);
    }
  }, [operationName, query, variables]);
};
```

</Surfer>

---

<L.Column>

## Our finished `useRequest` hook

- Creates our "Operations"
- Adds `key` to operations using hashing
- Does the minimum amount of work with hooks

</L.Column>

---

<Surfer>

```js title="Don't forget to update useQuery with the new useRequest argument"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest(query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    // ...
  }, [request]);

  return result;
};
```

```js 6 title="Don't forget to update useQuery with the new useRequest argument"
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest('query', query, variables);
  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    // ...
  }, [request]);

  return result;
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We've now prepared reusable operations that fully describe our internal GraphQL requests

</L.Row>

---

import Results from '../assets/results.svg';

<L.Row>

## Results.

### The internal structure we'll use to wrap around GraphQL results.

</L.Row>

<Results />

---

import CombinedError from '../assets/combined-error.svg';

<L.Row>

## Combined Errors.

### An abstraction to unify network and GraphQL errors.

</L.Row>

<CombinedError />

---

<Surfer>

```js title="CombinedError will just extend normal errors and have some extra info"
export class CombinedError extends Error {
  constructor({ networkError, graphQLErrors }) {
    super('');
  }
}
```

```js title="GraphQL errors will need to be deserialized"
import { GraphQLError } from 'graphql';

const rehydrateGraphQLError = (error => {
  if (typeof error === 'string') {
    return new GraphQLError(error);
  } else if (typeof error === 'object' && error.message) {
    return new GraphQLError(
      error.message,
      error.nodes,
      error.source,
      error.positions,
      error.path,
      error.originalError,
      error.extensions || {}
    );
  }
};

export class CombinedError extends Error {
  constructor({ networkError, graphQLErrors }) {
    super('');
  }
}
```

```js title="And we can generate a more meaningful error message for our CombinedError"
import { GraphQLError } from 'graphql';

const rehydrateGraphQLError = error => {
  if (typeof error === 'string') {
    return new GraphQLError(error);
  } else if (typeof error === 'object' && error.message) {
    return new GraphQLError(
      error.message,
      error.nodes,
      error.source,
      error.positions,
      error.path,
      error.originalError,
      error.extensions || {}
    );
  }
};

const makeErrorMessage = (networkError, graphQLErrors) => {
  if (networkError) {
    return '[Network] ' + networkError.message;
  } else if (graphQLErrors) {
    return graphQLErrors
      .map(({ message }) => `[GraphQL] ${message}`)
      .join('\n');
  } else {
    return '[CombinedError]';
  }
};

export class CombinedError extends Error {
  constructor({ networkError, graphQLErrors }) {
    super('');
  }
}
```

```js
const makeErrorMessage = (networkError, graphQLErrors) => {
  if (networkError) {
    return '[Network] ' + networkError.message;
  } else if (graphQLErrors) {
    return graphQLErrors
      .map(({ message }) => `[GraphQL] ${message}`)
      .join('\n');
  } else {
    return '[CombinedError]';
  }
};

export class CombinedError extends Error {
  constructor({ networkError, graphQLErrors }) {
    const rehydratedErrors = graphQLErrors
      ? graphQLErrors.map(rehydrateGraphQLError)
      : undefined;
    const message = makeErrorMessage(networkError, rehydratedErrors);

    super(message);

    this.name = 'CombinedError';
    this.message = message;
    this.graphQLErrors = rehydratedErrors;
    this.networkError = networkError;
  }
}
```

</Surfer>

---

import Signals from '../assets/signals.svg';

<L.Column>

## Operations as Events.

<Signals />

</L.Column>

---

<L.Column>

## Operations as Events.

Our new _Operations_ and _Results_ are abstractions that tell us all about
the lifecycle of GraphQL queries, including their _start_, _cancellation_, and
_results_.

</L.Column>

---

<L.Row>

## Client and Context.

### A central place for all of our configuration and logic.

</L.Row>

---

<Surfer>

```js title="We'll create our centralised client."
export class Client {
  constructor(url) {
    this.url = url;
  }
}
```

```js title="Next we'll move the fetch logic from our useQuery hook here."
const executeFetch = async (url, options) =>
  fetch(url, options)
    .then(res => {
      if (res.status < 200 || res.status >= 300) {
        throw new Error(res.statusText);
      } else {
        return res.json();
      }
    });

export class Client {
  constructor(url) {
    this.url = url;
  }
}
```

```js title="We'll add an execute method that basically does what our useQuery effect did."
import { print } from 'graphql';

// ... executeFetch

export class Client {
  constructor(url) {
    this.url = url;
  }

  execute = async (operation, cb) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(operation.query),
        variables: operation.variables
      })
    };

    try {
      const { data, errors } = await executeFetch(this.url, fetchOptions);
      cb({ data, errors });
    } catch (error) {
      cb({ data: undefined, errors: [error] });
    }
  };
}
```

```js title="We're adding our CombinedError to our central execute method"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url) {
    this.url = url;
  }

  execute = async (operation, cb) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(operation.query),
        variables: operation.variables
      })
    };

    try {
      const { data, errors } = await executeFetch(this.url, fetchOptions);
      cb({ data, errors });
    } catch (error) {
      cb({ data: undefined, errors: [error] });
    }
  };
}
```

```js title="We're adding our CombinedError to our central execute method"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url) {
    this.url = url;
  }

  execute = async (operation, cb) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(operation.query),
        variables: operation.variables
      })
    };

    try {
      const { data, errors } = await executeFetch(this.url, fetchOptions)
      cb({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      })
    } catch (networkError) {
      cb({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      })
    }
  };
}
```

</Surfer>

---

<L.Column>
<L.Row>

## React Context.

### We'll be creating a default client and a `useClient` hook

</L.Row>

```js
import { createContext, useContext } from 'react';
import { Client } from './Client';

export const Context =
  createContext(new Client('/graphql'));

export const useClient = () =>
  useContext(Context);
```

</L.Column>

---

<Surfer>

```js title="Let's remove the fetching logic from our useQuery hook."
import { useState, useEffect } from 'react';
import { print } from 'graphql';
import { useRequest } from './useRequest';

export const useQuery = ({ query, variables }) => {
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    data: undefined,
    error: undefined,
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    // ...
  }, [request]);

  return result;
};
```

```js title="...and replace the effect code to use client.execute."
import { useState, useEffect } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  return result;
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We've now created the initial client and are sending operations as well as normalizing results

</L.Row>

---

import OperationMetadata from '../assets/operation-metadata.svg';

<L.Row>

## Operation Metadata.

### Client options that will also be copied onto operations so that each of them may be configured separately.

</L.Row>

<OperationMetadata />

---

<Surfer>

```js
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url) {
    this.url = url;
  }

  execute = async (operation, cb) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(operation.query),
        variables: operation.variables
      })
    };

    // ...
  };
}
```

```js title="We'll add the new options to the client"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };
  }

  execute = async (operation, cb) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        query: print(operation.query),
        variables: operation.variables
      })
    };

    // ...
  };
}
```

```js title="On every execute we'll add the context to our operations"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    // ...
  };
}
```

```js title="Next, we'll move our result normalisation to executeFetch"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

// ... executeFetch

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    const result = await executeFetch(operation);
    cb(result);
  };
}
```

</Surfer>

---

<Surfer>

```js title="Next, we'll move our result normalisation to executeFetch"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

const executeFetch = async (url, options) =>
  fetch(url, options)
    .then(res => {
      if (res.status < 200 || status >= 300) {
        throw new Error(res.statusText);
      } else {
        return res.json();
      }
    });
```

```js title="Our executeFetch function will only need an operation going forward."
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

const executeFetch = async operation => {
  return fetch(url, options)
    .then(res => {
      if (res.status < 200 || status >= 300) {
        throw new Error(res.statusText);
      } else {
        return res.json();
      }
    });
};
```

```js title="We'll construct the options right at the top of executeFetch."
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

const executeFetch = async operation => {
  const { query, variables, context } = operation;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      query: print(query),
      variables
    }),
    headers: {
      'content-type': 'application/json',
      ...context.fetchOptions.headers
    },
    ...context.fetchOptions
  };

  return context.fetch(context.url, options)
    .then(res => {
      if (res.status < 200 || status >= 300) {
        throw new Error(res.statusText);
      } else {
        return res.json();
      }
    });
};
```

```js title="Then we're readding all of our result normalisation"
import { print } from 'graphql';
import { CombinedError } from './CombinedError';

const executeFetch = async operation => {
  const { query, variables, context } = operation;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      query: print(query),
      variables
    }),
    headers: {
      'content-type': 'application/json',
      ...context.fetchOptions.headers
    },
    ...context.fetchOptions
  };

  return context.fetch(context.url, options)
    .then(res => {
      if (res.status < 200 || status >= 300) {
        throw new Error(res.statusText);
      } else {
        return res.json();
      }
    })
    .then(({ data, errors }) => ({
      operation,
      data,
      error: errors
        ? new CombinedError({ graphQLErrors: errors })
        : undefined
    }))
    .catch(networkError => ({
      operation,
      data: undefined,
      error: new CombinedError({ networkError })
    }));
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### By adding Context we enable a strong separation of concerns, where all metadata is available right from Operations.

</L.Row>

---

<L.Row>

## What else?

### The Client can now become our central event hub, managing inputs and outputs as events.

</L.Row>

- Our hooks must become fully *reactive*, so we can *push results*.
- The client needs to track *active operations* and *dispose inactive* ones.
- Operations need to be *cancellable* and deduplicated.

---

import ClientArchitecture from '../assets/client-architecture.svg';

<L.Column>

## Client Architecture.

<ClientArchitecture />

</L.Column>

---

import ClientEventHub from '../assets/client-event-hub.svg';

<L.Column>

## Client as an Event Hub.

<ClientEventHub />

</L.Column>

---

<Surfer>

```js title="We'll now enable our hook to subscribe and unsubscribe from operations"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    const result = await executeFetch(operation);
    cb(result);
  };
}
```

```js title="We'll now enable our hook to subscribe and unsubscribe from operations"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="First we'll add an onOperationStart lifecycle method"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);

    executeFetch(operation).then(result => {
      listeners.forEach(listener => listener(result))
    });
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="First we'll add an onOperationEnd lifecycle method"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);

    executeFetch(operation).then(result => {
      listeners.forEach(listener => listener(result))
    });
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```diff
```

```js title="Lastly we'll also add an onResult method to make things a little clearer"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);

    executeFetch(operation).then(this.onResult);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

</Surfer>

---

<L.Column>

## Our finished Client (minus extensibility)

- It's a central hub for operations, basically an event emitter
- Hooks can subscribe to operations (and unsubscribe later)

</L.Column>

---

<Surfer>

```js title="Let's update useQuery to unsubscribe from operations as well"
import { useState, useEffect } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  return result;
};
```

```js title="Let's update useQuery to unsubscribe from operations as well"
import { useState, useEffect } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    return client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  return result;
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We now have the groundwork for a fully extensible and well structured GraphQL client.

</L.Row>

---

import Exchanges from '../assets/exchanges.svg';

<L.Row>

## Exchanges.

### Introducing an abstraction to handle how operations are fulfilled.

</L.Row>

<Exchanges />

---

import ExchangeStructure from '../assets/exchange-structure.svg';
import ExchangeSignature from '../assets/exchange-signature.svg';

<ExchangeStructure />

<Appear>
  <ExchangeSignature />
</Appear>

---

<Surfer>

```js title="Start with the raw exchange signature"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
  };
};
```

```js title="Start with the raw exchange signature"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;
  };
};
```

```js title="Rest of the exchange logic is basically our executeFetch function from earlier"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const options = {
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    return context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => ({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      }))
      .catch(networkError => ({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      }));
  };
};
```

```js title="Instead of returning results, we're sending them back to the client"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const options = {
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => ({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      }))
      .catch(networkError => ({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      }))
      .then(sendResult);
  };
};
```

```diff
```

</Surfer>

---

<L.Column>

## Our first Exchange

- Fully reusable and separate "unit of code"
- Moved the fetching concerns away from the Client

### This may seem familiar, if you've used _Redux or Express middleware_.

</L.Column>

---

<Surfer>

```js title="Let's integrate the exchange with our Client"
export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    executeFetch(operation).then(this.onResult);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="Let's integrate the exchange with our Client"
import { fetchExchange } from './fetchExchange';

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
    this.sendOperation = fetchExchange({
      client: this,
      forward: () => { /* noop */ }
    })(this.onResult);
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    executeFetch(operation).then(this.onResult);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="Now we're replacing our onOperationStart logic"
import { fetchExchange } from './fetchExchange';

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
    this.sendOperation = fetchExchange({
      client: this,
      forward: () => { /* noop */ }
    })(this.onResult);
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We have now moved the *fetching logic* to a reusable exchange which is entirely separate from the rest of the Client.

</L.Row>

---

<Surfer>

```js title="The second exchange we'll implement is the dedupExchange."
const dedupExchange = ({ forward }) => sendResult => {
  const activeOperations = new Set();

  return operation => {
  };
};
```

```js title="Since it's going to forward operations, we'll pass a closure to forward"
const dedupExchange = ({ forward }) => sendResult => {
  const activeOperations = new Set();
  const next = forward(result => {
    sendResult(result)
  });

  return operation => {
  };
};
```

```js title="When we receive operations we'll track them by their keys and filter out subsequent duplicates."
const dedupExchange = ({ forward }) => sendResult => {
  const activeOperations = new Set();
  const next = forward(result => {
    sendResult(result)
  });

  return operation => {
    if (!activeOperations.has(operation.key)) {
      activeOperations.add(operation.key);
      next(operation);
    }
  };
};
```

```js title="When we receive results, we'll remove the key to let identical operations through again."
const dedupExchange = ({ forward }) => sendResult => {
  const activeOperations = new Set();

  const next = forward(result => {
    activeOperations.delete(result.operation.key);
    sendResult(result)
  });

  return operation => {
    if (!activeOperations.has(operation.key)) {
      activeOperations.add(operation.key);
      next(operation);
    }
  };
};
```

```js title="Our special 'teardown' cancellation event needs to be handled as well."
const dedupExchange = ({ forward }) => sendResult => {
  const activeOperations = new Set();

  const next = forward(result => {
    activeOperations.delete(result.operation.key);
    sendResult(result)
  });

  return operation => {
    if (operation.operationName === 'teardown') {
      activeOperations.delete(operation.key);
      next(operation);
    } else if (!activeOperations.has(operation.key)) {
      activeOperations.add(operation.key);
      next(operation);
    }
  };
};
```

</Surfer>

---

<L.Column>

## `dedupExchange`

- Deduplicates incoming operations as long they're active
- Operations become inactive when a result for them comes back
- Operations also become inactive when they're cancelled using "teardown"

### But now that we have two exchanges, we need to _compose_ them.

</L.Column>

---

<Surfer>

```js title="Let's add a utility to compose exchanges"
export const composeExchanges = (client, exchanges) => {
  return exchanges.reduceRight((inner, exchange) => {
    return exchange({ client, forward: inner })
  }, fallback);
};
```

```js title="The last exchange in the chain must be a 'placeholder'"
export const composeExchanges = (client, exchanges) => {
  return exchanges.reduceRight((inner, exchange) => {
    return exchange({ client, forward: inner })
  }, fallback);
};

const fallback = sendResult => operation => {
  sendResult({
    operation,
    data: undefined,
    error: new CombinedError({
      networkError: new Error("Unhandled Operation")
    })
  });
};
```

```js title="The teardown event should be ignored"
export const composeExchanges = (client, exchanges) => {
  return exchanges.reduceRight((inner, exchange) => {
    return exchange({ client, forward: inner })
  }, fallback);
};

const fallback = sendResult => operation => {
  if (operation.operationName !== 'teardown') {
    sendResult({
      operation,
      data: undefined,
      error: new CombinedError({
        networkError: new Error("Unhandled Operation")
      })
    });
  }
};
```

</Surfer>

---

<Surfer>

```js title="Let's use our new exchanges"
import { fetchExchange } from './fetchExchange';

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
    this.sendOperation = fetchExchange({
      client: this,
      forward: () => { /* noop */ }
    })(this.onResult);
  }

  // ...
}
```

```js title="Let's use our new exchanges"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.listeners = {};
    this.sendOperation = fetchExchange({
      client: this,
      forward: () => { /* noop */ }
    })(this.onResult);
  }

  // ...
}
```

```js title="Let's use our new exchanges"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, context = {}) {
    this.context = {
      url,
      fetch: context.fetch || window.fetch.bind(window),
      fetchOptions: context.fetchOptions || {},
      requestPolicy: context.requestPolicy || 'cache-first'
    };

    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  // ...
}
```

```js title="Let's add a configuration option for exchanges"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges || [dedupExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  // ...
}
```


</Surfer>

---

import OperationFlow from '../assets/operation-flow.svg';

<L.Row>

## Operation Flow.

### An operation flows inwards through composed exchanges, and results bubble back up.

</L.Row>

<OperationFlow />

---

import TeardownFlow from '../assets/teardown-flow.svg';

<L.Row>

## Teardown Flow.

### We'll soon dispatch teardowns which flow inward through all exchanges, and cancel operations.

</L.Row>

<TeardownFlow />

---

<Background />

<L.Row>
<Cereal />

### We've now learned how to compose our new Exchanges and are ready to implement teardowns!

</L.Row>

---

<Surfer>

```js title="We're adding teardown events to the client"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges || [dedupExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="We're adding teardown events to the client"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges || [dedupExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

</Surfer>

---

<L.Row>

## The finished Operation Lifecycle.

### What's the deal with `onOperationStart` and `onOperationEnd`

</L.Row>

- We now add _listeners_ for each hook that calls `execute`.
- That returns an _unsubscribe_ function that is called when the hook unmounts or changes.
- When all listeners unsubscribe we send a _teardown event_ to the exchange pipeline.

---

<Surfer>

```js title="We can add an AbortController to make fetch cancellable"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const options = {
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, fetchOptions)
      .then(res => {
        if (res.status < 200 || status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => ({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      }))
      .catch(networkError => ({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      }))
      .then(sendResult);
  };
};
```

```js title="We can add an AbortController to make fetch cancellable"
const fetchExchange = ({ client, forward }) => sendResult => {
  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, fetchOptions)
      .then(res => {
        if (res.status < 200 || status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => ({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      }))
      .catch(networkError => ({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      }))
      .then(sendResult);
  };
};
```

```js title="We add a Map of relevant AbortControllers"
const fetchExchange = ({ client, forward }) => sendResult => {
  const controllers = new Map();

  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, fetchOptions)
      .then(res => {
        if (res.status < 200 || status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => ({
        operation,
        data,
        error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
      }))
      .catch(networkError => ({
        operation,
        data: undefined,
        error: new CombinedError({ networkError })
      }))
      .then(sendResult);
  };
};
```

```js title="AbortController signals operate by throwing a special error"
const fetchExchange = ({ client, forward }) => sendResult => {
  const controllers = new Map();

  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, fetchOptions)
      .then(res => {
        if (res.status < 200 || status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => {
        sendResult({
          operation,
          data,
          error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
        });
      })
      .catch(networkError => {
        if (networkError.name === 'AbortError') return;

        sendResult({
          operation,
          data: undefined,
          error: new CombinedError({ networkError })
        });
      });
  };
};
```

```js title="Let's make sure to also then clean up our Map"
const fetchExchange = ({ client, forward }) => sendResult => {
  const controllers = new Map();

  return operation => {
    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => {
        controllers.delete(operation.key);

        sendResult({
          operation,
          data,
          error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
        });
      })
      .catch(networkError => {
        controllers.delete(operation.key);
        if (networkError.name === 'AbortError') return;

        sendResult({
          operation,
          data: undefined,
          error: new CombinedError({ networkError })
        });
      });
  };
};
```

```js title="And finally, we'll handle teardown events"
const fetchExchange = ({ client, forward }) => sendResult => {
  const controllers = new Map();

  return operation => {
    if (operation.operationName === 'teardown') {
      const controller = controllers.get(operation.key);
      if (controller !== undefined) controller.abort();
      return;
    }

    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => {
        controllers.delete(operation.key);

        sendResult({
          operation,
          data,
          error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
        });
      })
      .catch(networkError => {
        controllers.delete(operation.key);
        if (networkError.name === 'AbortError') return;

        sendResult({
          operation,
          data: undefined,
          error: new CombinedError({ networkError })
        });
      });
  };
};
```

```js title="Our convention for Exchanges calls for all teardowns to be forwarded"
const fetchExchange = ({ client, forward }) => sendResult => {
  const next = forward(sendResult);
  const controllers = new Map();

  return operation => {
    if (operation.operationName === 'teardown') {
      const controller = controllers.get(operation.key);
      if (controller !== undefined) controller.abort();
      return next(operation);
    }

    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => {
        controllers.delete(operation.key);

        sendResult({
          operation,
          data,
          error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
        });
      })
      .catch(networkError => {
        controllers.delete(operation.key);
        if (networkError.name === 'AbortError') return;

        sendResult({
          operation,
          data: undefined,
          error: new CombinedError({ networkError })
        });
      });
  };
};
```

```js title="Our fetchExchange is last, so forwarding isn't necessary... unless we'd later add subscriptions!"
const fetchExchange = ({ client, forward }) => sendResult => {
  const next = forward(sendResult);
  const controllers = new Map();

  return operation => {
    if (operation.operationName === 'teardown') {
      const controller = controllers.get(operation.key);
      if (controller !== undefined) controller.abort();
      return next(operation);
    } else if (operation.operationName === 'subscription') {
      return next(operation);
    }

    const { query, variables, context } = operation;
    const { fetchOptions, url } = context;

    const controller = new AbortController();
    controllers.set(operation.key, controller);

    const options = {
      signal: controller.signal,
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "content-type": "application/json",
        ...fetchOptions.headers
      },
      ...fetchOptions
    };

    context.fetch(url, options)
      .then(res => {
        if (res.status < 200 || res.status >= 300) {
          throw new Error(res.statusText);
        } else {
          return res.json();
        }
      })
      .then(({ data, errors }) => {
        controllers.delete(operation.key);

        sendResult({
          operation,
          data,
          error: errors ? new CombinedError({ graphQLErrors: errors }) : undefined
        });
      })
      .catch(networkError => {
        controllers.delete(operation.key);
        if (networkError.name === 'AbortError') return;

        sendResult({
          operation,
          data: undefined,
          error: new CombinedError({ networkError })
        });
      });
  };
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We're now handling all events correctly, including teardowns.<br />This means that our client can handle all basic GraphQL operations.

</L.Row>

---

import CacheData from '../assets/cache-data.svg';

<L.Row>

## Document Caching.

### An easy way to optimise our GraphQL client generically is caching by operations.

</L.Row>

<CacheData />

---

import NormalisedCacheData from '../assets/normalised-cache-data.svg';

<L.Column>

### We're _not_ building a normalised cache.

<NormalisedCacheData />

</L.Column>

---

<Surfer>

```js title="Start with the basic exchange signature"
const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
  });

  return operation => {
    next(operation);
  };
};
```

```js title="Let's cache results as they come back"
const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return operation => {
    next(operation);
  };
};
```

```js title="Now we can read results from our cache"
const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return operation => {
    if (
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
    } else {
      next(operation);
    }
  };
};
```

```js title="Lastly we want to add some extra logic for request policies"
const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return operation => {
    const { requestPolicy } = operation.context;

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

</Surfer>

---

import Introspection from '../assets/introspection.svg';

<L.Row>

## Introspection.

### Inquiring the GraphQL API about types so we can add cache invalidation.

</L.Row>

<Introspection />

---

<Surfer>

```js title="We can use visit to create a visitor that adds typename fields"
import { visit, Kind } from 'graphql';

export const addTypenames = document =>
  visit(document, {
    Field: formatNode,
    InlineFragment: formatNode,
  });
```

```js title="The visitor function will add typename fields to each other Field and InlineFragment"
import { visit, Kind } from 'graphql';

const formatNode = node => {
  if (!node.selectionSet) {
    return false;
  }

  node.selectionSet.selections.push({
    kind: Kind.FIELD,
    name: {
      kind: Kind.NAME,
      value: '__typename'
    }
  });

  return node;
};

export const addTypenames = document =>
  visit(document, {
    Field: formatNode,
    InlineFragment: formatNode,
  });
```

```diff 4:6 title="We must ignore scalar fields without selections"
```

```js title="We also need to ignore nodes that already have typename fields"
import { visit, Kind } from 'graphql';

const isTypenameField = node =>
  node.kind === Kind.FIELD && node.name.value === '__typename';

const formatNode = node => {
  if (!node.selectionSet) {
    return false;
  } else if (node.selectionSet.selections.some(isTypenameField)) {
    return node;
  }

  node.selectionSet.selections.push({
    kind: Kind.FIELD,
    name: {
      kind: Kind.NAME,
      value: '__typename'
    }
  });

  return node;
};

export const addTypenames = document =>
  visit(document, {
    Field: formatNode,
    InlineFragment: formatNode,
  });
```

</Surfer>

---

<Surfer>

```js title="We want to implement a traverser that gets all types from a result"
export const collectTypes = (obj, types = new Set()) => {
  return types;
};
```

```js title="We want to implement a traverser that gets all types from a result"
export const collectTypes = (obj, types = new Set()) => {
  if (Array.isArray(obj)) {
    obj.forEach(inner => {
      collectTypes(inner, types);
    });
  } else if (typeof obj === 'object' && obj !== null) {
    Object.keys(obj).forEach(key => {
      if (key === '__typename') {
        types.add(obj[key]);
      } else {
        collectTypes(obj[key], types);
      }
    })
  }

  return types;
};
```

```diff 1[28:44] title="We'll add all types to a Set"
```

```diff 2:5 title="For arrays we recursively traverse all items"
```

```diff 8:9 title="On objects we add all typename values to the Set"
```

```diff 10:12 title="On objects we add all typename values to the Set"
```

</Surfer>

---

import DocumentCaching from '../assets/document-caching.svg';

<L.Row>

## Cache Invalidation.

### Our invalidation strategy is based on types in results.

</L.Row>

<DocumentCaching />

---

<Surfer>

```js title="Let's add collectTypes and addTypenames to our cacheExchange"
const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return operation => {
    const { requestPolicy } = operation.context;

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="Let's add collectTypes and addTypenames to our cacheExchange"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return operation => {
    const { requestPolicy } = operation.context;

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="First we'll use addTypenames to transform incoming queries"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="Then we'll collectTypes for each response"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();

  const next = forward(result => {
    const { data, error, operation } = result;
    const types = collectTypes(data);
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="Next we'll cache types"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();
  const typeCache = Object.create(null);

  const next = forward(result => {
    const { data, error, operation } = result;
    const types = collectTypes(data);
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);

      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.push(operation);
      });
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="And on mutations we'll invalidate some data"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();
  const typeCache = Object.create(null);

  const next = forward(result => {
    const { data, error, operation } = result;
    const types = collectTypes(data);
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);

      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.push(operation);
      });
    } else if (operation.operationName === 'mutation' && data) {
      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.forEach(op => client.reexecute(op));
        ops.length = 0;
      });
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="We'll also have to delete results on invalidation"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();
  const typeCache = Object.create(null);

  const next = forward(result => {
    const { data, error, operation } = result;
    const types = collectTypes(data);
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);

      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.push(operation);
      });
    } else if (operation.operationName === 'mutation' && data) {
      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.forEach(op => {
          resultCache.delete(op.key);
          client.reexecute(op);
        });
        ops.length = 0;
      });
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

```js title="And lastly, we don't want to forget the new request policy on reexecute"
import { collectTypes } from './collectTypes';
import { addTypenames } from './addTypenames';

const cacheExchange = ({ client, forward }) => sendResult => {
  const resultCache = new Map();
  const typeCache = Object.create(null);

  const next = forward(result => {
    const { data, error, operation } = result;
    const types = collectTypes(data);
    if (operation.operationName === 'query' && data && !error) {
      resultCache.set(operation.key, data);

      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.push(operation);
      });
    } else if (operation.operationName === 'mutation' && data) {
      types.forEach(type => {
        const ops = typeCache[type] || (typeCache[type] = []);
        ops.forEach(op => {
          resultCache.delete(op.key);
          client.reexecute({
            ...op,
            context: {
              ...op.context,
              requestPolicy: 'network-only'
            }
          })
        });

        ops.length = 0;
      });
    }

    sendResult(result);
  });

  return inputOperation => {
    const { requestPolicy } = inputOperation.context;
    const operation = {
      ...inputOperation,
      query: addTypenames(inputOperation.query)
    };

    if (
      requestPolicy !== 'network-only' &&
      operation.operationName === 'query' &&
      resultCache.has(operation.key)
    ) {
      const data = resultCache.get(operation.key);
      sendResult({ operation, data });
      if (requestPolicy === 'cache-and-network') {
        next(operation);
      }
    } else {
      next(operation);
    }
  };
};
```

</Surfer>

---

<L.Column>

## The finished `cacheExchange`

</L.Column>

- It caches by operation keys and respects request policies.
- It stores results and the types of results.
- It invalidates by mutation types overlapping with query result types.

### We're now left with implementing `client.reexecute`.

---

<Surfer>

```js title="Let's add the exchange to the Client"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges || [dedupExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="Let's add the exchange to the Client"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { cacheExchange } from './cacheExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges ||
      [dedupExchange, cacheExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="And we'll have to add the reexecute method"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { cacheExchange } from './cacheExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges ||
      [dedupExchange, cacheExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  reexecute = operation => {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    if (listeners.size > 0) {
      this.sendOperation(operation);
    }
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We've now successfully implemented a caching strategy for our GraphQL client and have added a way to reexecute active operations.

</L.Row>

---

<Surfer>

```js title="We'll need to make a small change to the client before starting useMutation"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { cacheExchange } from './cacheExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges ||
      [dedupExchange, cacheExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  reexecute = operation => {
    const { key } = operation
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    if (listeners.size > 0) {
      this.sendOperation(operation);
    }
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    this.onOperationStart(operation, cb);
    return () => this.onOperationEnd(operation, cb);
  };
}
```

```js title="Mutations are never cancelled so we'll need a special case to handle that"
import { fetchExchange } from './fetchExchange';
import { dedupExchange } from './dedupExchange';
import { cacheExchange } from './cacheExchange';
import { composeExchanges } from './composeExchanges';

export class Client {
  constructor(url, opts = {}) {
    this.context = {
      url,
      fetch: opts.fetch || window.fetch.bind(window),
      fetchOptions: opts.fetchOptions || {},
      requestPolicy: opts.requestPolicy || 'cache-first'
    };

    const exchanges = opts.exchanges ||
      [dedupExchange, cacheExchange, fetchExchange];
    this.sendOperation = composeExchanges(this, exchanges)(this.onResult);

    this.listeners = {};
  }

  onOperationStart(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.add(cb);
    this.sendOperation(operation);
  }

  onOperationEnd(operation, cb) {
    const { key } = operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.delete(cb);
    if (listeners.size === 0) {
      this.sendOperation({ ...operation, operationName: 'teardown' });
    }
  }

  onResult = result => {
    const { key } = result.operation;
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    listeners.forEach(listener => listener(result));
  };

  reexecute = operation => {
    const listeners = this.listeners[key] || (this.listeners[key] = new Set());
    if (listeners.size > 0) {
      this.sendOperation(operation);
    }
  };

  execute = async (baseOperation, cb) => {
    const operation = {
      ...baseOperation,
      context: {
        ...this.context,
        ...baseOperation.context
      }
    };

    if (operation.operationName === 'mutation') {
      const onResult = result => {
        cb(result);
        delete this.listeners[result.operation.key];
      };

      this.onOperationStart(operation, onResult);
    } else {
      this.onOperationStart(operation, cb);
      return () => this.onOperationEnd(operation, cb);
    }
  };
}
```

</Surfer>

---

<Surfer>

```js title="Next we'll start writing our useMutation hook"
import { useState } from 'react';
import { createRequest } from './useRequest';
import { useClient } from './Context';

export const useMutation = (query) => {
  const client = useClient();
  const [state, setState] = useState({
    fetching: false,
  });

  return [state];
};

```

```js title="Next we'll want to make function to execute the mutation"
import { useState } from 'react';
import { createRequest } from './useRequest';
import { useClient } from './Context';

export const useMutation = (query) => {
  const client = useClient();
  const [state, setState] = useState({
    fetching: false
  });

  const executeMutation = (variables) => {
    setState(res => ({ ...res, fetching: true }));
    const request = createRequest('mutation', query, variables);
  };

  return [state, executeMutation];
};

```

```js title="Our executeMutation will return a Promise which is never rejected"
import { useState } from 'react';
import { createRequest } from './useRequest';
import { useClient } from './Context';

export const useMutation = (query) => {
  const client = useClient();
  const [state, setState] = useState({
    fetching: false
  });

  const executeMutation = (variables) => {
    setState(res => ({ ...res, fetching: true }));
    const request = createRequest('mutation', query, variables);

    return new Promise((resolve, reject) => {
    })
  };

  return [state, executeMutation];
};

```

```js title="Inside the promise we'll get our client to execute the request"
import { useState } from 'react';
import { createRequest } from './useRequest';
import { useClient } from './Context';

export const useMutation = (query) => {
  const client = useClient();
  const [state, setState] = useState({
    fetching: false
  });

  const executeMutation = (variables) => {
    const request = createRequest('mutation', query, variables);
    setState(res => ({ ...res, fetching: true }));

    return new Promise((resolve, reject) => {
      client.execute(request, result => {
        setState({ ...result, fetching: false });
        resolve(result);
      });
    })
  };

  return [state, executeMutation];
};

```

```js title="Lastly we'll add useCallback to the executeMutation to prevent any extra work"
import { useState, useCallback } from 'react';
import { createRequest } from './useRequest';
import { useClient } from './Context';

export const useMutation = (query) => {
  const client = useClient();
  const [state, setState] = useState({
    fetching: false
  });

  const executeMutation = useCallback((variables) => {
    const request = createRequest('mutation', query, variables);
    setState(res => ({ ...res, fetching: true }));

    return new Promise((resolve, reject) => {
      client.execute(request, result => {
        setState({ ...result, fetching: false });
        resolve(result);
      });
    })
  }, [query, variables]);

  return [state, executeMutation];
};
```

</Surfer>

---

<Background />

<L.Row>
<Cereal />

### We've implemented a new `useMutation` hook with just a small change to the Client.

</L.Row>

---

<Surfer>

```js title="Next we'll add an executeQuery return value to our hook"
import { useState, useEffect, useCallback } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  useEffect(() => {
    setResult(res => ({ ...res, fetching: true }));

    return client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  return result;
};
```

```js title="We'll start by extracting the effect function"
import { useState, useEffect, useCallback } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  const executeQuery = async () => {
    setResult(res => ({ ...res, fetching: true }));

    return client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  };

  useEffect(() => {
    async function fetchQuery() {
      return await executeQuery()
    };

    fetchQuery()
  }), [request, client, executeQuery]);

  return result;
};
```

```js title="Then we'll wrap it in a useCallback"
import { useState, useEffect, useCallback } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  const executeQuery = useCallback(() => {
    setResult(res => ({ ...res, fetching: true }));

    return client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  useEffect(() => {
    async function fetchQuery() {
      return await executeQuery()
    };

    fetchQuery()
  }), [request, client, executeQuery]);

  return result;
};
```

```js title="And lastly we return it as a tuple"
import { useState, useEffect, useCallback } from 'react';
import { useRequest } from './useRequest';
import { useClient } from './Context';

export const useQuery = ({ query, variables }) => {
  const client = useClient();
  const request = useRequest('query', query, variables);

  const [result, setResult] = useState({
    fetching: true
  });

  const executeQuery = useCallback(() => {
    setResult(res => ({ ...res, fetching: true }));

    return client.execute(request, result => {
      setResult({
        ...result,
        fetching: false
      });
    });
  }, [request, client]);

  useEffect(executeQuery, [executeQuery]);

  return [result, executeQuery];
};
```

</Surfer>

---

<FormidableIntro />

More Questions? [@_philpl](https://twitter.com/_philpl) & [@sofiapoh](https://twitter.com/sofiapoh)

---

<Background />
<L.Row>

## There's always more that can be done.

<Cereal />
</L.Row>

- Logging exchange.
- Support for Subscriptions.
- Rewriting the Exchange pipeline with streams.
- Normalised caching.
